[
    {
        "title": "DES算法加密过程",
        "content": "1. DES算法将64比特的明文分组和64比特的密钥作为输入, 输出64位的密文分组. 其中密钥的8位为校验位,实际用到的只有56位.\n2. 共有3个步骤, 分别是IP置换, 16轮迭代和IP逆置换\n3. 此外密钥是通过密钥编排得到K1~K16共16个48位的子密钥\n4. IP置换是指用一个固定的初始置换IP来重排明文块的比特顺序, 将64位的明文分为两个32位的L0和R0\n5. 然后进行迭代,第一轮迭代输出两个块, 分别是L1和R1,其中L1是上面的R0, 而R1为上面的R0和K1经过轮函数之后再和L0通过模2运算得到的结果\n6. 轮函数具体包括5个步骤,首先是将R0进行E扩展, 就是根据E盒将R0扩展为48位, 然后将扩展后的值和K1进行密钥加, 也就是异或, 将结果写成8个比特串, 每个比特串6个比特\n7. 将每个比特串通过S盒代换变成8个4位的比特串\n8. 最后通过P置换就得到了这一轮迭代之后的结果\n9. 根据上面的轮函数的步骤, 进行16轮, 得到L16和R16, 再进行一次IP的逆置换就得到了最后的密文",
        "category": 1,
        "times": 0
    },
    {
        "category": 1,
        "title": "S盒是什么",
        "content": "S盒是一个4*16的矩阵, 其中矩阵的行对应输入的第一位和最后一位, 列对应输入的中间四位, 所以当输入一个6位的比特串时, 就可以知道对应这个矩阵的几行几列, 然后就可以得到唯一一个对应的四位比特串",
        "times": 0
    },
    {
        "category": 1,
        "title": "密钥编排的过程",
        "content": "将56位的密钥通过PC1变换分为了左右两个28位的部分, 分别是C_0和D_0。然后根据移位次数表, 按照上面轮函数迭代的次数分别进行左循环移位一位或者两位, 然后再经过PC2置换得到最后要求的48位的子密钥",
        "times": 0
    },
    {
        "category": 1,
        "title": "AES的加密过程",
        "content": "1. 明文的长度为128位, 密钥的长度是128位或192位或256位\n2. AES主要有三个步骤, 分别是初始变换, 9轮循环运算和1轮最终轮。\n3. 首先初始变换是将明文矩阵和子密钥矩阵通过异或运算得到初始变换的结果\n4. 然后是轮变换, 轮函数主要有四个步骤, 分别是字节代还, 行移位, 列混合和密钥加\n5. 首先是字节代换, 根据S盒进行代换, 得到一个新的4*4的矩阵\n6. 然后是行移位, 就是向左循环移位, 矩阵的第一行不动, 第二行左循环移位1位, 第三行左循环移位2位, 第四行左循环移位3位\n7. 之后是列混合, 将输入的4*4的矩阵左乘一个固定的矩阵, 得到列混合的结果\n8. 最后是子密钥加, 就是将得到的列混合的结果和轮密钥的对应部分进行异或, 得到最后轮函数的结果。这里的轮密钥是密钥通过轮密钥扩展得到的。\n9. 按照上述轮变换的过程进行9轮, 然后进行最后一轮的轮变换, 最后一轮的轮变换只进行字节代换, 行移位和子密钥加, 不进行列混合, 最后输出得到的密钥",
        "times": 0
    },
    {
        "category": 1,
        "title": "分组密码算法的运行模式有哪些",
        "content": "2. 有ECB(Electronic CodeBook mode), CBC(Cipher Block Chainning mode), CFB(Cipher Feedback mode), OFB(output feedback mode), CTR(CounTer mode)\n3. ECB：最简单的运行模式, 将明文分成若干个64bit的明文块, 每次用相同的密钥去加密。密文块可以分别独立解密, 无顺序要求。这种模式容易受到明文模式攻击和主动攻击\n4. CBC模式：使用初始向量和第一个分组异或, 然后加密, 之后的分组在加密之前都要和前一个分组的密文异或。这种模式可以防止明文模式攻击, 但是不提供完整性保护, 攻击者可以在传输过程中修改密文\n5. CFB模式：将明文分成若干个64比特的分组。取一个64比特的移位寄存器, 初值为一个随机的初始向量。首先对一个64比特的初始向量进行加密, 得到64比特的密钥流, 和明文的第一组进行异或, 产生密文的第一组, 然后将再次对刚刚得到的密文进行加密, 再和下一组明文异或, 这样不断进行下去, 得到的每个单元的密文进行组合就得到了最终的密文。CFB模式对传输错误非常敏感, 所以应该有完整性保护。\n6. CTR模式：将明文分组, 每组64bit。有一个随机向量和计数器, 分别为32bit, 两个合在一起得到64bit的随机向量。首先将随机向量通过密钥进行加密, 然后和第一组明文异或得到第一组密文。之后随机向量通过计数器加1, 再通过密钥加密, 然后和第二个分组得到第二组密文, 依次得到所有密文。",
        "times": 0
    },
    {
        "category": 1,
        "title": "什么是OTP",
        "content": "OTP是一次性密码, 是一种只能使用一次的密码, 随机密钥长度大于或等于明文长度具有完善保密性",
        "times": 0
    },
    {
        "category": 1,
        "title": "什么是流密码",
        "content": "流密码是一种重要的密码体制, 不同于分组密码将明文分成若干组去分别加密, 流密码将明文消息按照字符或者比特逐位的进行加密, 主要是使用高随机的密钥流去进行加密, 大多是通过硬件实现的。",
        "times": 0
    },
    {
        "category": 1,
        "title": " 密码学中，随机数有什么应用场景",
        "content": "1. 生成密钥, 用于对称密码和消息认证码\n2. 生成密钥对：用于公钥密码和数字签名\n3. 生成初始化向量, 用于CBC, CFB, OFB模式\n4. 生成随机数, 用于CTR模式\n5. 生成盐, 用于基于口令的密码",
        "times": 0
    },
    {
        "category": 1,
        "title": "同步流密码和自同步流密码是什么",
        "content": "1. 同步流密码是一种每个比特都依赖于相应密钥比特的密码系统, 需要在加密和解密时使用完全相同的密钥流\n2. 自同步流密码是密钥流不需要完全同步的密码系统, 在自同步流密码中, 密钥流的生成不仅依赖于密钥本身, 还依赖于先前的密文比特。\n3. 一般在可靠信道传输时使用同步流密码, 不可靠信道传输时使用自同步流密码\n4. CFB属于自同步流密码, CTR属于同步流密码",
        "times": 0
    },
    {
        "category": 1,
        "title": "什么是LFSR",
        "content": "LFSR是线性反馈移位寄存器, 由n位的移位寄存器和反馈函数组成的, 其中反馈函数是线性函数。当移位寄存器右移时, 最后一个存储单元的值输出, 第一个存储单元由反馈函数的输出值填充, 其中反馈函数通常是若干存储单元的异或得到",
        "times": 0
    },
    {
        "category": 1,
        "title": "LFSR中，什么是m序列呢",
        "content": "m序列是一种特殊的由LFSR生成的伪随机比特序列, 他的周期是2的n次减1, 也就是一个n级的LFSR的最大周期。他的反馈函数是一个特定的多项式函数, 也即本源多项式",
        "times": 0
    },
    {
        "category": 1,
        "title": "知道n级LFSR的密钥序列，如何计算反馈函数",
        "content": "取前2n个密钥序列, 然后建立矩阵方程, 即前n个密钥序列矩阵和反馈函数矩阵的矩阵乘的成绩应该为后n个密钥序列矩阵",
        "times": 0
    },
    {
        "category": 1,
        "title": "RC4算法的基本原理",
        "content": "RC4是属于对称密码中的流密码加密算法, 密钥长度可变, 面向字节操作。以一个足够大的S表为基础, 对表进行非线性变化, 产生密钥流。其主要步骤分为, 初始化S表, 密钥流的生成\n初始化S表首先对S表进行线性填充, 一般是256个字节, 然后用种子密钥填充另一个256字节的K表, 之后用K表对S表进行初始置换, 就得到了S表。\n密钥流的生成就是通过密钥调度算法对S表进行各种变换, 最后得到了一个伪随机数序列, 就是作为密钥流。\n最后用这个密钥流和明文进行异或就得到了密文",
        "times": 0
    },
    {
        "category": 1,
        "title": "哈希函数的性质",
        "content": "1. 确定性：它可以根据任意长度的消息计算出固定长度的散列值\n2. 抗修改性：输入的轻微的改变也会导致输出的哈希值发生巨大的变化\n3. 抗碰撞性, 对于两个不同的输出, 发生哈希值相等的情况的概率很小\n4. 唯一性, 消息不同, 散列值也不同\n5. 单向性, 只能从消息计算得到散列值, 而不能从散列值反推得到消息",
        "times": 0
    },
    {
        "category": 1,
        "title": "哈希函数可以用来干什么",
        "content": "1. 用于基于口令的加密\n2. 用于构造消息认证码\n3. 用于进行数字签名\n4. 用于构造伪随机数生成器\n5. 用于构造一次性口令",
        "times": 0
    },
    {
        "category": 1,
        "title": "举出几种哈希函数算法",
        "content": "MD4, MD5, SHA系列算法",
        "times": 0
    },
    {
        "category": 1,
        "title": "举出对哈希函数的攻击方式",
        "content": "暴力破解, 生日攻击",
        "times": 0
    },
    {
        "category": 1,
        "title": "什么是生日攻击",
        "content": "生日攻击是利用生日悖论进行的攻击, 攻击者可以生成多个输入, 然后用哈希函数进行处理, 然后查看是否具有相同的输出, 也就是是否发生了哈希碰撞。这样就可以在不改变哈希值的基础上对信息进行修改",
        "times": 0
    },
    {
        "category": 1,
        "title": "介绍一下SHA-256算法的具体步骤",
        "content": "1. 对消息进行补位处理, 使得最终的长度是512位的倍数\n2. 以512位为单位将消息分成若干块, 拆成16个32比特的消息, 然后通过循环右移和异或扩充为64个32比特的消息\n3. 用初始的8个哈希值对每一个512位的消息块进行加密, 得到新的8个哈希值, 这样循环下去, 当每一块都通过加密之后, 得到的就是最终的哈希值",
        "times": 0
    },
    {
        "category": 1,
        "title": "散列函数和消息认证码之间的区别",
        "content": "1. 哈希函数是通过对输入的数据进行加密, 转化为固定长度的输出数据, 用来验证消息的完整性, 一致性\n2. 消息认证码通过输入数据和共享密钥的加密来对消息的完整性和真实性进行验证。\n3. 哈希函数主要用于数据完整性验证方面\n4. 消息认证码主要用于身份验证",
        "times": 0
    },
    {
        "category": 1,
        "title": "可以通过什么方法来实现消息认证码",
        "content": "1. 使用SHA-2之类的哈希函数实现消息认证码\n2. 使用AES之类的对称加密算法来实现消息认证码, 使用CBC模式, 将前面生成的密文全部抛弃, 只留下最后一部分的密文作为MAC值",
        "times": 0
    },
    {
        "category": 1,
        "title": "消息认证码的攻击目的是什么",
        "content": "1. 密钥恢复攻击, 用来找到用户的密钥\n2. 伪造攻击, 用来在未知密钥的情况下伪造未经认证的消息和认证码",
        "times": 0
    },
    {
        "category": 1,
        "title": "HMAC计算MAC值的步骤",
        "content": "1. 首先将密钥填充为一个哈希函数的分组的长度\n2. 然后将填充后的密钥和ipad的比特序列进行异或运算, ipad是一个特定的比特序列\n3. 然后将运算后的值和消息进行组合, 放在消息的开头\n4. 将组合后的值输入到哈希函数, 计算出哈希值\n5. 将上面填充后的密钥和opad的比特序列进行异或运算, 然后后面拼上上一步得到的哈希值\n6. 将最后得到的这个哈希值再次输入到哈希函数中, 计算得到最终的哈希值, 也就是MAC值",
        "times": 0
    },
    {
        "category": 1,
        "title": "请介绍一下RSA加密算法的基本加密步骤",
        "content": "1. 首先取两个不相等且足够大的质数p和q\n2. 然后计算p和q的乘积n\n3. 之后计算n的欧拉函数$\\phi n$。\n4. 取一个和$\\phi n$互质的整数e\n5. 求出e对于$\\phi n$的模反元素d\n6. 然后公钥就是e和n的组合\n7. 私钥就是d和n的组合\n8. 加密时明文的e次方 mod n便是密文\n9. 解密时密文的d次方 mod n便是明文",
        "times": 0
    },
    {
        "category": 1,
        "title": "请说几种公钥加密的攻击方式",
        "content": "1. 中间人攻击\n2. 选择密文攻击",
        "times": 0
    },
    {
        "category": 1,
        "title": "介绍几种公钥密码",
        "content": "1. RSA\n2. Rabin\n3. 椭圆曲线密码",
        "times": 0
    },
    {
        "category": 1,
        "title": "相比于公钥密码，对称加密密码有什么缺陷呢",
        "content": "1. 当用对称加密算法加密后, 必须要将密钥告知接收方, 而在传输密钥的过程中, 可能会有风险\n2. 当在一个多人网络中需要两两用户安全通信时, 如果采用对称加密, 那么密钥的数量将会很多\n3. A收到B的文档时, 无法证明这个文档确实来自B",
        "times": 0
    },
    {
        "category": 1,
        "title": "说明用公钥加密传输数据的过程",
        "content": "比如Bob想要给Alice发送一个消息, 然后他让Alice生成一段公钥和私钥, 私钥由Alice自己保存, 公钥发送给Bob, Bob用公钥加密他要准备发送的消息, 然后将密文发给Alice, Alice收到密文之后用私钥就可以解锁密文得到明文",
        "times": 0
    },
    {
        "category": 1,
        "title": "数字签名的算法有哪些",
        "content": "1. RSA算法\n2. DSA算法\n3. 椭圆曲线数字签名",
        "times": 0
    },
    {
        "category": 1,
        "title": "介绍一下秘钥分发的步骤",
        "content": "这里介绍一下NS密钥分发协议的步骤\n1. 首先, A向KDC发送请求, 要求和B通信, 同时发送一个随机数\n2. KDC向A发送会话密钥, B的ID, 之前A向KDC发送的随机数和一个证书的加密信息, 用A和KDC的共享密钥加密。那个证书是用B和C的共享密钥加密后的会话密钥和A的ID\n3. A解密信息, 然后向B转交证书\n4. B解密证书, 并且向A发送一个用会话密钥加密后的随机数\n5. A相应B的请求, 并且将随机数减一, 用会话密钥加密后再发送回B",
        "times": 0
    },
    {
        "category": 1,
        "title": "什么是数字证书",
        "content": "数字证书是一种工具, 用来证明自己的身份和数据的真实性。数字证书中包含了一个人或组织的公钥及其相关信息, 包括证书名称, 过期日期等, 由可信任的第三方机构签名为凭证, 通常用于网站认证, 电子邮件加密和安全连接等。",
        "times": 0
    },
    {
        "category": 1,
        "title": "什么是PKI",
        "content": "PKI是生成、管理、存储、分发和吊销基于公钥密码学的公钥证书所需要的硬件、软件、人员策略和规程的总和",
        "times": 0
    }
]